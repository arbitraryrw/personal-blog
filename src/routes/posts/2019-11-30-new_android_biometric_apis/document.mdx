import styles from './document.module.css'

import face_prompt_confirmation_side_by_side from './imgs/face_prompt_confirmation_side_by_side.png'

import face_prompt_1 from './imgs/face_prompt_1.png'
import face_prompt_2 from './imgs/face_prompt_2.png'
import face_prompt_3 from './imgs/face_prompt_3.png'
import face_prompt_error from './imgs/face_prompt_error.png'
import face_prompt_confirmation_not_required_1 from './imgs/face_prompt_confirmation_not_required_1.png'
import face_prompt_confirmation_not_required_2 from './imgs/face_prompt_confirmation_not_required_2.png'
import finger_prompt_1 from './imgs/finger_prompt_1.png'
import biometricprompt_architecture from './imgs/biometricprompt_architecture.png'


<div className={styles["blogBody"]}>

## Introduction
Earlier this year Google released two new APIs to handle Biometric authentication with Android 10. The [BiometricManager](https://developer.android.com/reference/androidx/biometric/BiometricManager.html#constants_1) and [BiometricPrompt](https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt) classes. The purpose of these APIs is to provide a centralised mechanism for interfacing with biometric authentication mechanisms on Android, regardless of the hardware of the device i.e fingerprint / face.

The main reason Iâ€™m writing this is because I found it very difficult to find any information on integrating [CryptoObjects](https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.CryptoObject) with the new API, especially anything in Kotlin. With that in mind, the aim of this post is to talk about the new biometric architecture, to showcase a basic example of the new APIs using Crypto Objects, and highlight some of the inherent risks introduced with these new APIs.

## Background
The new Biometric APIs have been in alpha / beta since [last September](https://mvnrepository.com/artifact/androidx.biometric/biometric), however, they have only just been fully released, as can be seen [here](https://mvnrepository.com/artifact/androidx.biometric/biometric/1.0.0
). Originally it was rumoured that these APIs were to handle Facial Recognition exclusively because of this [commit](https://android-review.googlesource.com/c/platform/frameworks/base/+/640360/), however this is not true. These APIs are built with the intention of unifying biometric authentication mechanisms. They currently support fingerprint and face authentication with the view of integrating other modalities in the future, such as [iris](https://source.android.com/security/biometric#implementation).

## New Biometric Architecture
The two new APIs superseed the old [FingerprintManager](https://developer.android.com/reference/android/hardware/fingerprint/FingerprintManager) that was used for handling fingerprint biometrics on Android devices. Notably, the [FingerprintManager](https://developer.android.com/reference/android/hardware/fingerprint/FingerprintManager) class was deprecated in API level 28. The flow diagram across android versions can be seen below, the original image can be found in the Android Developer documentation [here](https://source.android.com/security/biometric#implementation).

<img src={biometricprompt_architecture} className={styles["screenshot"]} alt="Image Source: https://source.android.com/security/biometric#implementation" />

According to the developer documentation [here](https://source.android.com/security/biometric): `"All biometric implementations must meet security specifications and have a strong rating in order to participate in the BiometricPrompt class"`. For more information on the guidelines, see [here](https://source.android.com/compatibility/android-cdd#7_3_10_biometric_sensors) and [here](https://source.android.com/security/biometric/measure#strong-weak-unlocks).

## Project setup
In order to leverage the new APIs, the project must include the androidx biometric dependency and have the required permission present in the Android Manifest.

Add the androidx biometric library to the application by referencing it in the project's dependency list found in `app/build.gradle`, as seen below:

```gradle
dependencies {
    implementation 'androidx.biometric:biometric:1.0.0'
}
```

Add the `USE_BIOMETRIC` permission to the project's Android manifest file found in `app/src/main/AndroidManifest.xml`, as seen below:

```xml
<uses-permission android:name="android.permission.USE_BIOMETRIC"
    android:requiredFeature="false"/>
```

## BiometricManager Usage
The [BiometricManager](https://developer.android.com/reference/androidx/biometric/BiometricManager.html#constants_1) class provides a centralised mechanism for querying the availability of biometric authentication on the device. Notably, under the hood this will invoke the [FingerprintManagerCompat](https://developer.android.com/reference/androidx/core/hardware/fingerprint/FingerprintManagerCompat.html) class on pre Android P devices. A simple example of how to invoke this method can be seen below:

```kotlin
when (biometricManager.canAuthenticate()) {
    BiometricManager.BIOMETRIC_SUCCESS ->
        println("Biometrics available on the device")
    BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE ->
        println("No biometric features available on this device.")
    BiometricManager.BIOMETRIC_ERROR_HW_UNAVAILABLE ->
        println("Biometric features are currently unavailable.")
    BiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED ->
        println("User has not setup biometrics with their account.")
}
```
The `canAuthenticate` method returns one of 4 constant values that can be used to identify the biometric status of the device. Handle and act appropriately, next let's look at leveraging biometrics into this flow.

## BiometricPrompt Usage - Showing a Dialogue
The [BiometricPrompt](https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt) class provides a consistent and centralised mechanism for managing the system-provided biometric dialog. First, let's look at building the BiometricPrompt PromptInfo object. This can be done by leveraging the builder method as seen below:

```kotlin
var biometricPromptInfo = BiometricPrompt.PromptInfo.Builder()
            .setTitle("Nik.re Login")
            .setSubtitle("Biometric Auth")
            .setDescription("Performing x function to do y")
            .setNegativeButtonText("Abort biometric login")
            .setConfirmationRequired(true)
            .setDeviceCredentialAllowed(false)
            .build()
```

Many of the APIs referenced in the snippet above are for setting cosmetic attributes such as `.setTitle` and `.setDescription`, used to set dialogue information. However the `setConfirmationRequired` and `setDeviceCredentialAllowed` are interesting from a security perspective.

The `setConfirmationRequired` method is used to define whether or not the dialogue should require explicit user action when performing authentication. This is important when considering implicit biometric modalities like Face and Iris authentication which are passive by design. Meaning they don't require an explicit user action to complete. It is recommended to set this flag to `true` when performing high risk actions such as making a purchase, or sending a payment. Low-risk actions such as re-authenticating a recently authenticated session may want to consider setting this flag to `false`. Notably, this setting acts as a hint to the system, meaning the system may choose to ignore the flag. For example, if the user disables implicit authentication in Settings, or if it does not apply to a modality such as fingerprint. More information on this API can be found [here](https://developer.android.com/reference/androidx/biometric/BiometricPrompt.PromptInfo.Builder#setConfirmationRequired(boolean)). See the image below for a side by side comparison.

<img src={face_prompt_confirmation_side_by_side} className={styles["screenshot"]} alt="BiometricPrompt setConfirmationRequired side by side" />

The `setDeviceCredentialAllowed` method is used to define whether or not the dialogue should give the user the option to authenticate with their device PIN, pattern, or password. This allows the user to choose between authenticating using their biometric or their device authentication method. There are a number of additional considerations when enabling this API, such as checking if the device is secured with a PIN, pattern or password. This can be done by using the [KeyguardManager.isDeviceSecure](https://developer.android.com/reference/android/app/KeyguardManager.html#isDeviceSecure()) and [KeyguardManager.isKeyguardSecure](https://developer.android.com/reference/android/app/KeyguardManager.html#isKeyguardSecure()) APIs. More information on this API can be found [here](https://developer.android.com/reference/androidx/biometric/BiometricPrompt.PromptInfo.Builder#setDeviceCredentialAllowed(boolean)). For the purposes of this example this flag is disabled.

The next step is to initialise the BiometricPrompt itself and create handlers for the many authentication callbacks BiometricPrompt can return, a full list of these callbacks can be found [here](https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.AuthenticationCallback). See below a basic example of this to configure this.

```kotlin
val executor = ContextCompat.getMainExecutor(this)

val biometricPrompt = BiometricPrompt(this, executor,
  object : BiometricPrompt.AuthenticationCallback() {
      override fun onAuthenticationError(errorCode: Int,
                                         errString: CharSequence) {
          super.onAuthenticationError(errorCode, errString)
          Toast.makeText(applicationContext,
              "Authentication error: $errString", Toast.LENGTH_SHORT)
              .show()
      }

      override fun onAuthenticationSucceeded(
          result: BiometricPrompt.AuthenticationResult) {
            super.onAuthenticationSucceeded(result)
            val authenticatedCryptoObject: BiometricPrompt.CryptoObject?
              = result.getCryptoObject()
            // User has verified the signature, cipher, or message
            // authentication code (MAC) associated with the crypto
            //object, use this in your app's crypto-driven workflows.


            Toast.makeText(applicationContext, "Authentication Success!",
                Toast.LENGTH_SHORT)
                .show()
      }

      override fun onAuthenticationFailed() {
          super.onAuthenticationFailed()
          Toast.makeText(applicationContext, "Authentication failed",
              Toast.LENGTH_SHORT)
              .show()
      }
  })
```

The authentication process can then begin by invoking the [authenticate](https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.html#authenticate(android.os.CancellationSignal,%20java.util.concurrent.Executor,%20android.hardware.biometrics.BiometricPrompt.AuthenticationCallback)) method on the `BiomtricPromt` object and passing in the `BiometricPrompt.PromptInfo` object we created earlier as a paramter. An example of this can be seen below:

```kotlin
biometricPrompt.authenticate(promptInfo)
```

This will then present the biometric dialogue seen earlier. Depending on the result of the biometric authentication process this will then invoke the callback logic we registered earlier. In this example it will simply display a toast message.

## BiometricPrompt Usage - Using Crypto Objects
In the developer documentation there are two available versions of the `BiometricPrompt.authenticate` API as can be seen [here](https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.html#public-methods_1). In the previous example we used the version that does not leverage [BiometricPrompt.CryptoObject](https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.CryptoObject.html) as a parameter, lets take look a look at the version that does.



## TODO REMOVE IMAGES
<img src={face_prompt_1} className={styles["screenshot"]} alt="Facial recognition prompt" />
<img src={face_prompt_2} className={styles["screenshot"]} alt="Facial recognition post authentication / pre confirmation" />
<img src={face_prompt_3} className={styles["screenshot"]} alt="Facial recognition post authentication confirmation" />
<img src={face_prompt_error} className={styles["screenshot"]} alt="Facial recognition prompt error" />
<img src={face_prompt_confirmation_not_required_1} className={styles["screenshot"]} alt="Pre authentication - no user confirmation required" />
<img src={face_prompt_confirmation_not_required_2} className={styles["screenshot"]} alt="Post authentication - no user confirmation required" />
<img src={finger_prompt_1} className={styles["screenshot"]} alt="Fingerprint prompt" />

```
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)Â 
Caused by: android.security.KeyStoreException: Key user not authenticated
at android.security.KeyStore.getKeyStoreException(KeyStore.java:1292)
```




## Conclusion
The new Biometric APIs provide an easy to use solution for handling biometrics on Android. The abstracted logic makes it easy for a developer to integrate biometric authentication without having to worry about the modality supported by the device, i.e face / finger / iris. Additionally, from a development perspective the lifecycle aware and consistent UI components are really nice to work with.

With that being said, from a security perspective, these new biometric APIs introduce a risk by not allowing developers to control / restrict biometric modalities. Organisations may not feel comfortable with biometric x but may be comfortable with biometric y. Especially when handling sensitive information such as the key example in this post. Ideally, these APIs should provide some mechanism to control this, such as via an initialisation flag to BiometricPrompt or a Manifest permission. If this is an issue sticking with the deprecated FingerprintManager class is probably the best option.

The full source code can be found on my Github [here](https://github.com/arbitraryrw/biometric-prompt-demo/). Additionally, Google provides a useful tutorial for integrating the new Biometric APIs which can be found [here](https://developer.android.com/training/sign-in/biometric-auth).

# References and Further Reading
- [Android - Biometric Security Overview](https://source.android.com/security/biometric)
- [Android - Measuring Biometric Security](https://source.android.com/security/biometric/measure#metrics)
- [Google Source - Biometric APIs](https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/hardware/biometrics)
- [Developer Docs - BiometricManager](https://developer.android.com/reference/androidx/biometric/BiometricManager)
- [Developer Docs - BiometricPrompt](https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt)
- [Developer Docs - Basic Integration Guide](https://developer.android.com/training/sign-in/biometric-auth)

</div>
